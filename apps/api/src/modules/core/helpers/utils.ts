import { Module, ModuleMetadata, Type } from '@nestjs/common';
import chalk from 'chalk';
import deepmerge from 'deepmerge';
import { isNil } from 'lodash';

import { PanicOption } from '../types';

/**
 * 生成只包含字母的固定长度的字符串
 * @param length
 */
export const getRandomCharString = (length: number) => {
  let result = '';
  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
  const charactersLength = characters.length;
  for (let i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
};

/**
 * 判断一个函数是否为异步函数
 * @param callback
 */
export function isAsyncFn<R, A extends Array<any>>(
  callback: (...asgs: A) => Promise<R> | R,
): callback is (...asgs: A) => Promise<R> {
  const AsyncFunction = (async () => {}).constructor;
  return callback instanceof AsyncFunction === true;
}

/**
 * 用于请求验证中的boolean数据转义
 * @param value
 */
export function toBoolean(value?: string | boolean): boolean {
  if (isNil(value)) return false;
  if (typeof value === 'boolean') return value;
  try {
    return JSON.parse(value.toLowerCase());
  } catch (error) {
    return value as unknown as boolean;
  }
}

/**
 * 用于请求验证中转义null
 * @param value
 */
export function toNull(value?: string | null): string | null | undefined {
  return value === 'null' ? null : value;
}

/**
 * 深度合并对象
 * @param x 初始值
 * @param y 新值
 * @param arrayMode 对于数组采取的策略,`replace`为直接替换,`merge`为合并数组
 */
export const deepMerge = <T1, T2>(
  x: Partial<T1>,
  y: Partial<T2>,
  arrayMode: 'replace' | 'merge' = 'merge',
) => {
  const options: deepmerge.Options = {};
  if (arrayMode === 'replace') {
    options.arrayMerge = (_d, s, _o) => s;
  } else if (arrayMode === 'merge') {
    options.arrayMerge = (_d, s, _o) => Array.from(new Set([..._d, ...s]));
  }
  return deepmerge(x, y, options) as T2 extends T1 ? T1 : T1 & T2;
};

/**
 * 创建一个动态模块
 * @param target
 * @param metaSetter
 */
export function CreateModule(
  target: string | Type<any>,
  metaSetter: () => ModuleMetadata = () => ({}),
): Type<any> {
  let ModuleClass: Type<any>;
  if (typeof target === 'string') {
    ModuleClass = class {};
    Object.defineProperty(ModuleClass, 'name', { value: target });
  } else {
    ModuleClass = target;
  }
  Module(metaSetter())(ModuleClass);
  return ModuleClass;
}

/**
 * 输出命令行错误消息
 * @param option
 */
export async function panic(option: PanicOption | string) {
  console.log();
  if (typeof option === 'string') {
    console.log(chalk.red(`\n❌ ${option}`));
    process.exit(1);
  }
  const { error, message, exit = true } = option;
  !isNil(error) ? console.log(chalk.red(error)) : console.log(chalk.red(`\n❌ ${message}`));
  if (exit) process.exit(1);
}
